\documentclass[notitlepage,aps,amsmath,amssymb,11pt]{revtex4-1}
\usepackage{hyperref}
\usepackage{graphicx}

\newcommand{\divv}{\nabla \cdot}
\newcommand{\curl}{\nabla \times}
\newcommand{\curlb}[1]{\left\{ #1 \right\}}
\newcommand{\sqb}[1]{\left[ #1 \right]}
\newcommand{\rndb}[1]{\left( #1 \right)}
\newcommand{\norm}[1]{\left| #1 \right|}
\renewcommand{\vec}[1]{\boldsymbol{#1}}
\newcommand{\tens}[1]{\boldsymbol{#1}}
\newcommand{\diff}[2]{\frac{\rm d#1}{\rm d#2}}
\newcommand{\pdiff}[2]{\frac{\partial#1}{\partial#2}}

\begin{document}

\title{Simulations of Knots in Excitable Media}
\author{Carl Whitfield}
\affiliation{Department of Physics, University of Warwick, Coventry, United Kingdom, CV3 7AL}
\date{\today}
\begin{abstract}
A summary of (and user guide for) simulations of knotted vortex lines in a Fitzhugh-Nagumo reaction-diffusion system in C$++$. I first introduce the problem briefly by discussing relevant background before detailing the contents of the code and outlining some preliminary results.
\end{abstract}
\maketitle
\tableofcontents

\section{Background}

\subsection{Excitable Media and the FitzHugh-Nagumo Model}

An excitable medium is one where the individual constituents can change state due to stimulation by an external cue, such as a chemical concentration. This covers a wide range of systems from biological tissues to wildfires. Of particular interest are excitable media that recover (i.e. can be re-excited), which include many biological examples as well as some chemical reactions. A simple model of the continuum behaviour of such a system is given by the FitzHugh-Nagumo model equations for fields $u$ and $v$
\begin{align}
\label{dudt} \pdiff{u}{t} &= \frac{1}{\epsilon}( u - u^3/3 - v) + \nabla^2 u\\
\label{dvdt} \pdiff{v}{t} &= \epsilon(u + \beta - \gamma v) \, . 
\end{align}
Originally, the model was used to describe axon activity where $u$ is the membrane potential and $v$ a recovery variable \cite{FitzHugh1955, Nagumo1962} and did not include the diffusion term. In the absence of diffusion the equations are a generalised form of the van der Pol oscillator with amplitude of driving $\epsilon$. The inclusion of the diffusion term couples neighbouring oscillators allows travelling wave solutions. Thus this system of equations is commonly used to describe phenomena in various reaction diffusion systems including spiral waves in cardiac tissue. 


\section{Numerical Simulation Code}

\subsection{Outline}

Generating knotted vortex lines in the FitHugh-Nagumo equations requires formulating initial conditions with the correct topology and geometry. This is achieved using a continuous circle-valued function $\Phi$ with a singularity located along the knotted curve $K$ that we wish to initialise, around which $\Phi$ winds by $2 \pi$. The initial conditions for $u$ and $v$ are then given by \cite{Sutcliffe2003}
\begin{align}
\label{uinit} u_0 &= \cos{\Phi} - 0.4\\
\label{vinit} v_0 &= \sin{\Phi} - 0.4 \, .
\end{align}
The offset $-0.4$ is the approximate value of $u$ and $v$ at the centre of the scroll wave core, and approximately the average value about which $u$ and $v$ oscillate. Not only does this mean that locally around the filament, the $u$ and $v$ fields resemble a scroll wave (figure ... ) but also they have matching topology. Wavefronts of $u$ and $v$ form orientable surfaces bounded only by the knot curve (Seifert surfaces). Similarly, the `function' $\Phi$ foliates all of space with a family of Seifert surfaces, therefore the wavefronts of $u_0$ and $v_0$ are also Seifert surfaces.

The phase $\Phi$ is calculated as the scalar potential of a curl-free magnetic field (or equivalently an irrotational flow in a inviscid fluid) around a current carrying wire $K$ with position vector $\vec{l}$ via the Biot-Savart law:
\begin{align}
\label{phik} \Phi = \int_{\vec{r}_0}^{\vec{r}} \vec{B}(\vec{r}') . {\rm d} \vec{r}'
\end{align}
where
\begin{align}
\label{B} \vec{B}(\vec{r}) = \frac{1}{2} \int_K \frac{(\vec{r} - \vec{l})\times {\rm d} \vec{l}}{\norm{\vec{r} - \vec{l}}^3} \, .
\end{align}
Thus, our chosen $\Phi$ is harmonic as well as having the desired topological properties. By Stokes' theorem, the integral can be rewritten in terms of a surface integral
\begin{align}
\label{phis} \Phi = \frac{1}{2} \int_S \frac{( \vec{l} - \vec{r} )}{\norm{ \vec{l} - \vec{r} }^3 }\cdot {\rm d} \vec{S} \, .
\end{align}

On initialisation the simulation code defines the grid of points discretising the three-dimensional domain to be simulated. The size of the box in the $x$ direction is defined by \verb'size' ($L$) and the number of points discretising this direction by \verb'Nx' ($N_x$) such that the spatial step size $h = L/(N_x-1)$. The size of the box in $y$ and $z$ is then just $N_y h$ and $N_z h$ so that the grid spacing is uniform in all directions. Arrays defining quantities on this grid (\emph{e.g.} \verb'phi') are one dimensional, with entries $n = N_z ( N_y i + j) + k$ where $i,j,k$ are the indices for the $x,y,z$ coordinates respectively. Usually, loops over the whole array are of the format
\begin{verbatim}
for(i=0;i<Nx;i++)
{
      for(j=0; j<Ny; j++)
      {
          for(k=0; k<Nz; k++)
          {
               n = pt(i,j,k);
               .....
          }
     }
}
\end{verbatim} 
where the inline function \verb'pt' simply returns the one-dimensional index $n$. Henceforth we will use subscript $n$ or $i,j,k$ to denote array indices on the three-dimensional grid, depending on the context.

\subsection{Initialisation Method I: Surface Integral}

Seifert surfaces have been created by hand using Surface Evolver to triangulate and refine the surface with a fixed boundary curve (generally obtained from KnotPlot). These are stored as \verb'.stl' files, which simply list the properties of each triangular face in the following format
\begin{verbatim}
facet normal nx ny nz
   outer loop
     vertex v1x v1y v1z
     vertex v2x v2y v2z
     vertex v3x v3y v3z
   endloop
  endfacet
\end{verbatim}
where \verb'ni' is the $i$th component of the (normalised) vector normal to the face and \verb'vij' is the $jth$ component of the position vector of the $i$th vertex (all given in floating point format). This is read by the C++ code via the function \verb'init_from_surface_file'. This currently requires only 2 variables as input, the filename of the \verb'.stl' file and a pointer to a vector of the structure \verb'triangle' (both of which are declared as a global variables in the code). The structure \verb'triangle' is defined
\begin{verbatim}
struct triangle
{
    double xvertex[3];  
    double yvertex[3];   
    double zvertex[3];   
    double normal[3];   
    double area;      
    double centre[3];  
};
\end{verbatim}
such that \verb'xvertex' stores the x-components of the 3 vertices, \verb'normal' stores the components of the normal vector, \verb'area' stores the area of the triangle and \verb'centre' the components of the centroid of the triangle. 

The function \verb'init_from_surface_file' reads in the values for the vertices and normals until it reaches the \verb'endsolid' tag at the end of the \verb'.stl' file, storing the total number of faces in $N_K$ (\verb'NK' in the code). Generally the index used to denote the triangle is \verb's' in the code, so we will use subscript $s$ to indicate quantities of the triangle. The centroid is then simply calculated as the mean of the vertices. The function also records the maximum and minimum $x$, $y$ and $z$ coordinates of vertices on the surface as \verb'minxin' ($x^{\rm min}$), \verb'maxxin' ($x^{\rm max}$) \emph{etc.} All surface points $\vec{r}_s$ are then transformed
\begin{align}
\label{rxs} r^{(x)}_s = \frac{X^{\rm max}}{x^{\rm max} - x^{\rm min}}\biggl[r^{(x)}_s - \frac{1}{2}\bigl(x^{\rm max} + x^{\rm min}\bigr)\biggr] \\
\label{rys} r^{(y)}_s = \frac{Y^{\rm max}}{y^{\rm max} - y^{\rm min}}\biggl[r^{(y)}_s - \frac{1}{2}\bigl(y^{\rm max} + y^{\rm min}\bigr)\biggr]  \\
\label{rzs} r^{(z)}_s = \frac{Z^{\rm max}}{z^{\rm max} - z^{\rm min}}\biggl[r^{(z)}_s - \frac{1}{2}\bigl(z^{\rm max} + z^{\rm min}\bigr)\biggr] 
\end{align}
where ($X^{\rm max}$, $Y^{\rm max}$, $Z^{\rm max}$) are the user defined bounds for the knot size (\verb'xmax',\verb'ymax',\verb'zmax'). The surface normal is then scaled accordingly:
\begin{align}
n^{(x)}_s &= n^{(x)}_s\frac{Y^{\rm max} Z^{\rm max}}{\bigl(y^{\rm max} - y^{\rm min}\bigr)\bigl(z^{\rm max} - z^{\rm min}\bigr)}\\
n^{(y)}_s &= n^{(y)}_s\frac{X^{\rm max} Z^{\rm max}}{\bigl(x^{\rm max} - x^{\rm min}\bigr)\bigl(z^{\rm max} - z^{\rm min}\bigr)}\\
n^{(z)}_s &= n^{(z)}_s\frac{X^{\rm max} Y^{\rm max}}{\bigl(x^{\rm max} - x^{\rm min}\bigr)\bigl(y^{\rm max} - y^{\rm min}\bigr)}
\end{align}
and then normalised. Finally, the area of triangle $n$ is calculated from the vertices (Heron's formula):
\begin{align}
A_s &= \sqrt{p(p-r_{21})(p-r_{20})(p-r_{10})} 
\end{align}
where $p = (r_{21} + r_{20} + r_{10})/2$ and $r_{ij} = \norm{\vec{r}_i - \vec{r}_j}$ and $\vec{r}_i$ are the vertices of the triangles. 

The code next calls \verb'initialise_knot' which in turn calls \verb'phi_calc' where the phase field $\Phi$ is calculated at every point in the domain. The surface integral of equation \eqref{phis} is approximated by 
\begin{align}
\label{phin} \Phi_{n} = \sum_{s=0}^{N_K}  \frac{(\vec{c}_s - \vec{x}_{n})}{\norm{\vec{c}_s - \vec{x}_{n}}^3}\cdot \hat{\vec{n}}_s A_s
\end{align}
where $\vec{c}_s$ is the position vector of the centre of triangle $s$. $\Phi_n$ is calculated for all $n$, but contributions to the sum in \eqref{phin} where $\norm{\vec{c}_s - \vec{x}_{n}} = 0$ are skipped. Then, as $\Phi$ is circle valued we redefine it to lie in the range $\Phi \in [-\pi,\pi]$. The resulting $\Phi$ field should be a foliation of the three-dimensional domain with the knot as its boundary, an example plot of level-sets of $\Phi$ is given in figure \ref{fig:phi}.
\begin{figure}[h!]
\centering
\includegraphics[width=0.8\columnwidth]{phi.png}
\caption{Level-set surfaces of the function $\Phi$ sliced along the $y$ direction for visibility. The green surface shows the input surface (which has an unlink as its boundary). }
\label{fig:phi}
\end{figure}

\subsection{Initialisation Method II: Line Integral}

The option \verb'FROM_KNOT_FILE' indicates that the phase field $\phi$ should be calculated by line integral via the function \verb'init_from_knot_file'. This takes a \verb'.txt' file with a list of point coordinates as input for the knot curve storing them in the vectors \verb'px', \verb'py', \verb'pz' and and also storing the maximum and minimum values of the $x$, $y$ and $z$ components in this list as \verb'minxin', \verb'maxxin' \emph{etc}. The knot curve position vector $(xt,yt,zt)$ is then scaled accordingly as in equations \eqref{rxs}, \eqref{rys} and \eqref{rzs}.

This curve is then further subdivided by linear interpolation between the points to have $N_k =  2 L / h $ (rounded to nearest integer) points, stored in the (vector) arrays \verb'X', \verb'Y' and \verb'Z'. We refer to the position vector of each point as $\vec{l}_s = (X_s, Y_s, Z_s)$. 

The magnetic field is then computed by the function \verb'B_field_calc' called by \verb'initial_cond' at all points on an $N_x \times N_y \times N_z$ grid by summing this quantity over all the points on the loop $s=(1..N_k)$ according to equation \eqref{B}:
\begin{align}
\vec{B}_{i,j,k} = \sum_{s=1}^{N_k} \frac{(\vec{x}_{i,j,k}-\vec{l}_s) \times {\rm d}\vec{l}_s}{\norm{\vec{r}_{i,j,k}-\vec{l}_s}^3}
\end{align}
where $d \vec{l}_s = (d \vec{l}_{s+1} - d \vec{l}_{s-1})/2$. \\

Finally the scalar potential $\Phi$ is computed at all points by the path integral in equation \eqref{phik} for all points. We choose the initial point $\vec{r}_0$ to be the origin of our coordinate system and set $\phi=0$ at $\vec{r}=\vec{r}_0$. To save computation time, we first calculate the path integral on the vertices of the 3-dimensional domain filling in all the values of $\Phi$ on the chosen path in the process, and looping inwards (skipping points that are already filled). {\bf This integral could perhaps be sped up more by looping over the faces of the domain first in this manner and working inwards, as this should assign most points in the domain relatively quickly.} Given a path of $N_p$ gridpoints $(i_p, j_p, k_p)$ connecting $\vec{r}_0$ to the destination point $\vec{r}$, $\Phi$ is computed iteratively along the path as:
\begin{align}
\Phi_{i_p,j_p,k_p} = \Phi_{i_{p-1},j_{p-1},k_{p-1}}  + \frac{1}{2}(\vec{B}_{i_p,j_p,k_p} + \vec{B}_{i_{p-1},j_{p-1},k_{p-1}})\cdot(\vec{r}_{i_p,j_p,k_p} - \vec{r}_{i_{p-1},j_{p-1},k_{p-1}}) 
\end{align}
for $p \in [1:N_p-1]$ where $\Phi_{0,0,0}=0$ and $(i_0,j_0,k_0) = 0$.

The path from the origin to the point in question is found by the function \verb'pathfind'. It was found that simple straight-line paths can give rise to significant numerical errors resulting in incorrect initialisation when the paths come within some small neighbourhood of the knot curve (of approximately one `core diameter' $d_0 = \lambda/\pi$). To avoid these points we fill an empty array \verb'ignore' with the value 1 at every gridpoint where $\norm{\vec{r}_{i,j,k}-\vec{l}_s} < d_0$ for any $s=0..N_k-1$ of the initial curve (this array is computed once during the magnetic field calculation). 

In order to compute the path itself, from a point $(i,j,k)$ we define a preferred direction, $\vec{p} = ({\rm sgn}(i_f-i),{\rm sgn}(j_f-j),{\rm sgn}(k_f-k))$, then if the point corresponding to $\vec{i}+\vec{p}$ (where $\vec{i}=(i,j,k)$) is free to move into, this becomes the next point in the path. Note that a path is forbidden from revisiting a previous point, each time a point is visited the zero array $T_{i,j,k}$ is marked with a $1$. If, this point is not free ($A_{\vec{i}+\vec{p}}=1$ or $T_{\vec{i}+\vec{p}}=1$) then instead we sample all neighbouring points and choose the one that maximises a particular preference condition. In this case that condition is a sum of the alignment with direction to final point and alignment to the magnetic field (which helps to avoid the path spiralling around when it hits a wall). If no neighbour points are viable, we step back to the previous point on the path and repeat the previous step, now with the dead-end point unable to be revisited as $T_{i,j,k}=1$.



3a) The pathfinding algorithm\\

Since the knot $K$ is a 1D object, the chances of our 3D path integral passing exactly through it are quite slim (depending on how we initialise it). However, the magnetic field diverges on $K$ so in order to avoid numerical errors, we choose to ignore a region around $K$. We do this by filling an empty $N_x \times N_y \times N_z$ array $A^1_{i,j,k}$ with a 1 at each point in the grid where the quantity $\norm{\vec{r}_{i,j,k}-\vec{l}_n} < \lambda/2$ for any $n=1..N_k$ where $\lambda$ is the diameter of the vortex core. We also define a second array $A^2_{i,j,k}$ filled in when $\norm{\vec{r}_{i,j,k}-\vec{l}_n} < \lambda/20$ for any $n=1..N_k$. Then, if the point we wish to find a path to, say $\vec{r}_{i_f,j_f,k_f}$, satisfies $A^1_{i_f,j_f,k_f}=0$ then a path is computed that avoids any points with $A^1_{i,j,k}=1$. If $A^1_{i_f,j_f,k_f}=1$ and $A^2_{i_f,j_f,k_f}=0$ then a path is computed that avoids any points with $A^2_{i,j,k}=1$. If $A^2_{i_f,j_f,k_f}=1$ then this point is not assigned a value. One of course should check that the the volume defined by $A^1_{i_f,j_f,k_f}=0$ is connected and includes the origin..\\

In order to compute the path itself, from a point $(i,j,k)$ we define a preferred direction, $\vec{p} = ({\rm sgn}(i_f-i),{\rm sgn}(j_f-j),{\rm sgn}(k_f-k))$, then if the point corresponding to $\vec{i}+\vec{p}$ (where $\vec{i}=(i,j,k)$) is free to move into, this becomes the next point in the path. Note that a path is forbidden from revisiting a previous point, each time a point is visited the zero array $T_{i,j,k}$ is marked with a $1$. If, this point is not free ($A_{\vec{i}+\vec{p}}=1$ or $T_{\vec{i}+\vec{p}}=1$) then instead we sample all neighbouring points and choose the one that maximises a particular preference condition. In this case that condition is a sum of the alignment with direction to final point and alignment to the magnetic field (which helps to avoid the path spiralling around when it hits a wall). If no neighbour points are viable, we step back to the previous point on the path and repeat the previous step, now with the dead-end point unable to be revisited as $T_{i,j,k}=1$.

\section{Initialisation from file}

There is also the option to initialise a simulation from a previous run of the code. One can initialise from the \verb'phi.vtk' file outputted after calculation of the $\Phi$ field using the option \verb'FROM_PHI_FILE' and defining the string variable \verb'B_filename' as the local path to the input \verb'.vtk' file. This \verb'phi.vtk' file must be from a previous run of the code with the same grid size and spacing settings. 

Similarly, one can continue from the Fitzhugh-Nagumo variables $u$ and $v$ using option \verb'FROM_UV_FILE' and setting \verb'B_filename' as the local path to the input \verb'.vtk' file. Again, this \verb'uv_plotXXX.vtk' file should be from a previous run of the code with the same grid size and spacing settings.  In this case, it may be desirable to start the time counter from the last point of the previous run of the code, in which case set \verb'starttime' $=$ XXX. Otherwise \verb'starttime' should be set to zero. 

\section{FitzHugh-Nagumo Dynamics}

Once $\Phi$ is calculated the Fitzhugh-Nagumo variables are initialised in \verb'uv_initialise' as given by equations \eqref{uinit} and \eqref{vinit}. If initialisation method II is used (\verb'FROM_KNOT_FILE') then $u$ and $v$ are set to -0.4 in the regions that are skipped (as this is the approximate value they take at the centre of the scroll wave:
\begin{verbatim}
for(n=0; n<Nx*Ny*Nz; n++)
{
    u[n] = (2*cos(phi[n]) - 0.4);
    v[n] = (sin(phi[n]) - 0.4);
    if(option==FROM_KNOT_FILE && missed[n]==1)
    {
        u[n] = -0.4;
        v[n] = -0.4;
    }
}
\end{verbatim}

Following initialisation the code iterates the FitzHugh-Nagumo dynamics through time with time spacing \verb'dtime'. There are two method options in the code for this, set by the value of the preprocessor parameter \verb'RK4'. If \verb'RK4' is nonzero then the fourth-order Runge-Kutta method is used (function call \verb'uv_update'), otherwise a simple Euler forward method is employed (function call \verb'uv_update_euler'). In both cases, a simple central difference scheme is used to approximate the Lagrangian of $u$:
\begin{align}
\nabla^2 u_{i,j,k} \approx \frac{1}{h^2} ( u_{i-1,j,k} + u_{i,j-1,k} + u_{i,j,k-1} - 6 u_{i,j,k} + u_{i+1,j,k} +  u_{i,j+1,k}  +  u_{i,j,k+1} ) \, . 
\end{align}
The boundary conditions are usually taken to be of the Neumann type, i.e. $\nabla u = 0$ at the wall. We take the walls to be positioned half a gridspace before the first gridpoint, and half a gridspace after the final gridpoint so that Neumann boundary conditions demand
\begin{align}
u_{-1, j, k} = u_{0,j,k}\\
u_{N_x, j, k} = u_{N_x-1,j,k}
\end{align}
and likewise for the $y$ and $z$ directions. This is incorporated into the code by the function \verb'incw(int i, int p, int N)' which is used to take increments of $i,j,k$ around the current gridpoint. The function returns $i+p$ unless that is outside the range $[0:N-1]$ in which case the counter is `reflected' back into the domain
\begin{verbatim}
inline int incw(int i, int p, int N)   
{
    if(i+p<0) return (-(i+p+1));
    if(i+p>N-1) return (2*N-(i+p+1));
    return (i+p);
}
\end{verbatim} 
Currently, by setting the boolean parameter \verb'periodic' as true then this changes the boundary conditions to periodic {\bf in the z direction only}. Then, the periodic increment function \verb'incp(int i, int p, int N)' is used
\begin{verbatim}
inline int incp(int i, int p, int N)   
{
    if(i+p<0) return (N+i+p);
    else return ((i+p)%N);
}
\end{verbatim} 
in which case the counter continues back at $0$ if it goes above $N-1$ and \emph{vice versa}. To switch to fully periodic boundaries all occurences of \verb'incw' should be replaced by \verb'incp'.

\subsubsection{Euler-forward update}

The Lagrangian of u is stored in the array \verb'D2u' and once this is defined everywhere $u$ and $v$ are updated by the discretised versions of equations \eqref{dudt} and \eqref{dvdt} 
\begin{align}
u^{t+\delta t}_{i,j,k} &= u^{t}_{i,j,k} + \delta t \sqb{ \frac{1}{\epsilon} \rndb{u^{t}_{i,j,k} - \frac{1}{3}(u^{t}_{i,j,k})^3 - v^{t}_{i,j,k}} + \nabla^2 u^{t}_{i,j,k}}\\
v^{t+\delta t}_{i,j,k} &= v^{t}_{i,j,k} + \epsilon \delta t \rndb{ u^{t}_{i,j,k} + \beta - \gamma v^{t}_{i,j,k} } \, .
\end{align}
where the superscript indicates the time at which these quantities are defined.

\subsubsection{Runge-Kutta update}

In this method there is 3 extra `correction' steps after the initial `predictor' update which help to stabilise the dynamics at large values of $\delta t$ (\verb'dtime'). This involves 3 intermediate updates of $u$ and $v$ which we denote with superscripts $t+\delta t/4$,  $t+\delta t/2$ and $t+3\delta t/4$ (although the steps do not correspond to these times) such that
\begin{align}
u^{t+\delta t / 4}_{i,j,k} &= u^{t}_{i , j, k} + \frac{\delta t}{2} f\rndb{u_{i,j,k}^t, v_{i,j,k}^t} \\
u^{t+\delta t / 2}_{i,j,k} &= u^{t}_{i , j, k} + \frac{\delta t}{2} f\rndb{u_{i,j,k}^{t+\delta t / 4}, v_{i,j,k}^{t+\delta t / 4}}\\
u^{t+3\delta t / 4}_{i,j,k} &= u^{t}_{i , j, k} + \delta t \, f\rndb{u_{i,j,k}^{t+\delta t / 2}, v_{i,j,k}^{t+\delta t / 2}}\\
v^{t+\delta t / 4}_{i,j,k} &= v^{t}_{i , j, k} + \frac{\delta t}{2} g\rndb{u_{i,j,k}^t, v_{i,j,k}^t} \\
v^{t+\delta t / 2}_{i,j,k} &= v^{t}_{i , j, k} + \frac{\delta t}{2} g\rndb{u_{i,j,k}^{t+\delta t / 4}, v_{i,j,k}^{t+\delta t / 4}}\\
v^{t+3\delta t / 4}_{i,j,k} &= v^{t}_{i , j, k} + \delta t \, g\rndb{u_{i,j,k}^{t+\delta t / 2}, v_{i,j,k}^{t+\delta t / 2}}
\end{align}
where
\begin{align}
f\rndb{u_{i,j,k}^t, v_{i,j,k}^t} &= \frac{1}{\epsilon} \rndb{u^{t}_{i,j,k} - \frac{1}{3}(u^{t}_{i,j,k})^3 - v^{t}_{i,j,k}} + \nabla^2 u^{t}_{i,j,k} \\
g\rndb{u_{i,j,k}^t, v_{i,j,k}^t} &= u^{t}_{i,j,k} + \beta - \gamma v^{t}_{i,j,k}
\end{align}
These operations are performed in the function \verb'uv_add' where the return value of $f$ and $g$ (at the current intermediate timestep) is stored in the arrays \verb'ku' and \verb'kv' and then the array \verb'kut' and \verb'kvt' keep a running total of their contributions to the final update equations:
\begin{align}
u^{t+\delta t}_{i,j,k} = u^{t}_{i , j, k} + \frac{\delta t}{6} \sqb{ f_{i,j,k}^t + 2 f_{i,j,k}^{t+\delta t / 4}  + 2f_{i,j,k}^{t+\delta t / 2} +  f_{i,j,k}^{t+3\delta t / 4}}\\
v^{t+\delta t}_{i,j,k} = v^{t}_{i , j, k} + \frac{\delta t}{6} \sqb{ g_{i,j,k}^t + 2 g_{i,j,k}^{t+\delta t / 4}  + 2g_{i,j,k}^{t+\delta t / 2} +  g_{i,j,k}^{t+3\delta t / 4}}
\end{align}
where the shorthand $f_{i,j,k}^t = f\rndb{u_{i,j,k}^t, v_{i,j,k}^t}$ is used. Note this method uses approximately twice as much RAM than the Euler forward method due the extra arrays that are necessary.

\subsubsection{Output}

The code tracks the time dependent behaviour of $u$ and $v$ by outputting these fields after every \verb'skiptime' units of time. The \verb'startime' variable sets the stating value for the time counter, it should only be set to a value other than zero if initialising from a previous run so that the output files match. All outputs are in the form of VTK files, and can be read directly into Paraview. 

Firstly, the function \verb'crossgrad_calc' calculates the value of $\norm{\nabla u \times \nabla v}$ (stored in \verb'ucv') at all points using finite difference methods. This is approximately 0 everywhere except in a vortex core. Thus, as show in figure \ref{fig:knot}, one can locate the vortex core by plotting the isosurfaces of $\norm{\nabla u \times \nabla v} = 0.1$.

The fields $\phi$, and $u$, $v$, and $\norm{\nabla u \times \nabla v}$ are outputted in the functions \verb'print_B_phi' and \verb'print_uv' respectively. They use the ``Structured Points'' (legacy) vtk format, meaning that the grid is parametrised in the files by the spacing, number of points, and origin position, which saves storage space compared to printing out the location of all points. The fields are printed as ``point data'' meaning that they are defined as that value on the grid points (this can be converted by paraview into ``cell data'' defined for each grid cube).

The knot curve (see following section) is outputted by \verb'print_knot'. This is a 1D line of points, and so is outputted as an ``Unstructured Grid''. In this case we specify the location of each points and also define cells (lines in this case) connecting them sequentially. Then, data defined on the points is outputted as point data and terms that depend on the gradient of point data (like twist and writhe) are defined as cell data (as the values are strictly defined between two points due to the use of forward difference for the derivatives).

\subsection{Numerical ``Hummingbird''}

To track the properties of the knotted vortex line we write a function which locates and traces the curve with a one-dimensional array of points, we nickname  this function the ``Hummingbird'' due to Winfree's comment in \cite{Winfree1990}. 

The algorithm is employed by the function \verb'find_knot_properties' and works by using the vector $\vec{t} = \nabla u \times \nabla v/\norm{\nabla u \times \nabla v}$ to approximate the local tangent of the vortex core \cite{Winfree1990}. The algorithm uses this recursively to map out points in the knot, starting at the gridpoint with the largest value of $\norm{\nabla u \times \nabla v}$ (calculated in \verb'crossgrad_calc'). We also confine the Hummingbird to the region of large $\norm{\nabla u \times \nabla v}$ with an effective potential, such that we update its position vector $\vec{h}$  (stored in \verb'vector<knotpoint> knotcurve') as:
\begin{align}
\vec{h}_{s+1} = \vec{h}_s + \frac{\lambda}{32 \pi} \sqb{\vec{t}_{s} + 0.2 \frac{[\nabla \norm{\nabla u \times \nabla v}]_s}{\norm{[\nabla \norm{\nabla u \times \nabla v}]_s}}\cdot(\mathbb{I} - \vec{t}_s\vec{t}_s)} \, .
\end{align}
The distance scale $\lambda/32$ ($\approx 1/16$ of the core radius) is used to ensure that the Hummingbird stays confined. The first term in the bracket simply moves the Hummingbird according the (interpolated) tangent vector. The second term corrects this move by adding a small force in the direction of the local maximum $\norm{\nabla u \times \nabla v}$ (which should be approximately at the core centre. This is projected onto the normal plane of the tangent vector to avoid affecting the step length much. We choose to normalise the confining force in order to have control over its magnitude, but this method could be the cause of small oscillations in the Hummingbird's path.

The local values of $\vec{t}_{s}$ and $[\nabla \norm{\nabla u \times \nabla v}]_s$ are interpolated linearly from the surrounding 8 gridpoints where they are computed by finite difference methods. 

This algorithm is repeated until the Hummingbird has taken at least 32 steps ($\approx$ distance of core diameter) and has returned to within a core single radius $\lambda/2\pi$ of its initial location. The algorithm is also terminated at $s=50000$ in the event that the Hummingbird fails to make it home. There is also a fail-safe in the case where the Hummingbird does leave the core region. If the local interpolated value of $\norm{\nabla u \times \nabla v}_s < 0.1$ we deem that the Hummingbird has left the core, at which point the algorithm is paused, and this point is moved along the direction of $[\nabla \norm{\nabla u \times \nabla v}]_s$ until $\norm{\nabla u \times \nabla v}_s \geq 0.1$. If this is not achieved within 20 attempts the algorithm gives up and carries on regardless.

{\bf Post-processing} 



\section{Convergence and Accuracy Tests}

\section{Results}

\section{Future Directions and Open Questions}

\begin{thebibliography}{10}
\bibitem{Maucher2016} F. Maucher and P. Sutcliffe \href{http://dx.doi.org/10.1103/PhysRevLett.116.178101}{Phys. Rev. Lett. {\bf 116}(178101) (2016)}

\end{thebibliography}

\end{document}