#include "FN_knot_surface.h"    //contains some functions and all global variables/*Available options: FROM_PHI_FILE: Skip initialisation, input from previous run. FROM_SURFACE_FILE: Initialise from input file(s) generated in surface evolver.  FROM_UV_FILE: Skip initialisation, run FN dynamics from uv file */unsigned int option = FROM_SURFACE_FILE;         //unknot default option//const bool addtwist = false;/**If FROM_SURFACE_FILE chosen**/string knot_filename = "five_two";      //assumed input filename format of "XXXXX.stl" for single component or "XXXXXi.txt" for i=1..ncomp for multiple components/**IF FROM_PHI_FILE or FROM_UV_FILE chosen**/string B_filename = "phi_in.vtk";    //filename for phi field or uv field//Grid pointsunsigned int Nx = 200;   //No. points in x,y and zunsigned int Ny = 200;unsigned int Nz = 150;double TTime = 4000;         //total time of simulation (simulation units)double skiptime = 100;       //print out every # unit of time (simulation units)double starttime = 0;        //Time at start of simulation (non-zero if continuing from UV file)double dtime = 0.05;         //size of each time step//Size parameters for knotdouble lambda = 21.3;                //approx wavelengthdouble coresize;   //approx core diameterconst double epsilon = 0.3;                //parameters for F-N eqnsconst double beta = 0.7;const double gam = 0.5;//System size parametersdouble size,h,xmax,ymax,zmax;int NK;   //number of surface points//Unallocated matricesvector<triangle> knotsurface;    //structure for storing knot surface coordinatesdouble area;   //initial knot areainline int pt(int i, int j, int k)       //convert i,j,k to single index{    return (i*Ny*Nz+j*Nz+k);}int main (void){    double *x, *y, *z, *phi, *u, *v, *ucv, *d2u, *d2v;    int *missed;    int i,j,k,n,t;        x = new double [Nx];    y = new double [Ny];    z = new double [Nz];    u = new double [Nx*Ny*Nz];    v = new double [Nx*Ny*Nz];    ucv = new double [Nx*Ny*Nz];    d2u = new double [Nx*Ny*Nz];    d2v = new double [Nx*Ny*Nz];    phi = new double [Nx*Ny*Nz];  //scalar potential    missed = new int [Nx*Ny*Nz];        size = 10*lambda;    h = size/(Nx-1);    coresize = 3*h;    xmax = Nx*h/4;   //max grid point knot can inhabit    ymax = Ny*h/4;   //must be < N*h/2    zmax = Nz*h/4;        for(i=0;i<Nx;i++)           //initialise grid    {        x[i] = (i+0.5-Nx/2.0)*h;    }    for(j=0;j<Ny;j++)    {        y[j] = (j+0.5-Ny/2.0)*h;    }    for(k=0;k<Nz;k++)    {        z[k] = (k+0.5-Nz/2.0)*h;    }        if (option == FROM_PHI_FILE)    {        cout << "Reading input file...\n";        phi_file_read(phi,missed);    }    else    {        if(option == FROM_UV_FILE)        {            cout << "Reading input file...\n";            if(uvfile_read(u,v)) return 1;        }        else        {            //Initialise knot            area = initialise_knot();            if(area==0)            {                cout << "Error reading input option. Aborting...\n";                return 1;            }                        cout << "Total no. of surface points: " << NK << endl;                        //Calculate phi for initial conditions            initial_cond(x,y,z,phi,missed);        }    }        if(option!=FROM_UV_FILE)    {        cout << "Calculating u and v...\n";        uv_initialise(phi,u,v,ucv,missed);    }        delete [] missed;    delete [] phi;    delete [] x;    delete [] y;    delete [] z;        double timesec = 60.0*Nx*Ny*Nz/(1000.0*101*101*81*dtime);    unsigned int tt = ((int) timesec);    cout << "Updating u and v: " << tt/60 << "m " << tt%60 << "s per unit T.\n";    int p=0;    n=0;    while(n*dtime<TTime)    {        if(n*dtime >= p*skiptime)        {            crossgrad_calc(u,v,ucv);            print_uv(u,v,ucv,n*dtime+starttime);            cout << "T = " << n*dtime + starttime << endl;            p++;        }        uv_update(u,v);        n++;    }        delete [] u;    delete [] v;    delete [] ucv;    delete [] d2u;    delete [] d2v;        return 0;}/*************************Functions for knot initialisation*****************************/double initialise_knot(){    double L;    switch (option)    {        case FROM_SURFACE_FILE: L = init_from_surface_file();            break;                default: L=0;            break;    }        return L;}double init_from_surface_file(void){    string filename, buff;    stringstream ss;    double A = 0;   //total area    int i=0;    int j;    double r10,r20,r21,s,xcoord,ycoord,zcoord;    string temp;    ifstream knotin;        ss.clear();    ss.str("");    ss << knot_filename << ".stl";        filename = ss.str();    knotin.open(filename.c_str());    if(knotin.good())    {        if(getline(knotin,buff)) temp = buff;    }    else cout << "Error reading file\n";    while(knotin.good())   //read in points for knot    {        if(getline(knotin,buff))  //read in surface normal        {            ss.clear();            ss.str("");            if(buff=="endsolid") break;            ss << buff;            knotsurface.push_back(triangle());            ss >> temp >> temp >> knotsurface[i].normal[0] >> knotsurface[i].normal[1] >> knotsurface[i].normal[2];        }                if(getline(knotin,buff)) temp = buff;   //read in "outer loop"        knotsurface[i].centre[0] = 0;        knotsurface[i].centre[1] = 0;        knotsurface[i].centre[2] = 0;        for(j=0;j<3;j++)        {            if(getline(knotin,buff))  //read in vertices            {                ss.clear();                ss.str("");                ss << buff;                ss >> temp >> xcoord >> ycoord >> zcoord;                knotsurface[i].xvertex[j] = zmax*xcoord;                knotsurface[i].yvertex[j] = zmax*ycoord;                knotsurface[i].zvertex[j] = zmax*zcoord;                knotsurface[i].centre[0] += knotsurface[i].xvertex[j]/3;                knotsurface[i].centre[1] += knotsurface[i].yvertex[j]/3;                knotsurface[i].centre[2] += knotsurface[i].zvertex[j]/3;            }        }                if(getline(knotin,buff)) temp = buff;   //read in "outer loop"        if(getline(knotin,buff)) temp = buff;   //read in "outer loop"                        r10 = sqrt((knotsurface[i].xvertex[1]-knotsurface[i].xvertex[0])*(knotsurface[i].xvertex[1]-knotsurface[i].xvertex[0]) + (knotsurface[i].yvertex[1]-knotsurface[i].yvertex[0])*(knotsurface[i].yvertex[1]-knotsurface[i].yvertex[0]) + (knotsurface[i].zvertex[1]-knotsurface[i].zvertex[0])*(knotsurface[i].zvertex[1]-knotsurface[i].zvertex[0]));        r20 = sqrt((knotsurface[i].xvertex[2]-knotsurface[i].xvertex[0])*(knotsurface[i].xvertex[2]-knotsurface[i].xvertex[0]) + (knotsurface[i].yvertex[2]-knotsurface[i].yvertex[0])*(knotsurface[i].yvertex[2]-knotsurface[i].yvertex[0]) + (knotsurface[i].zvertex[2]-knotsurface[i].zvertex[0])*(knotsurface[i].zvertex[2]-knotsurface[i].zvertex[0]));        r21 = sqrt((knotsurface[i].xvertex[2]-knotsurface[i].xvertex[1])*(knotsurface[i].xvertex[2]-knotsurface[i].xvertex[1]) + (knotsurface[i].yvertex[2]-knotsurface[i].yvertex[1])*(knotsurface[i].yvertex[2]-knotsurface[i].yvertex[1]) + (knotsurface[i].zvertex[2]-knotsurface[i].zvertex[1])*(knotsurface[i].zvertex[2]-knotsurface[i].zvertex[1]));        s = (r10+r20+r21)/2;        knotsurface[i].area = sqrt(s*(s-r10)*(s-r20)*(s-r21));            //cout << knotsurface[i].area << " (" << knotsurface[i].centre[0] << ',' << knotsurface[i].centre[1] << ',' << knotsurface[i].centre[2] << ") , (" << knotsurface[i].normal[0] << ',' << knotsurface[i].normal[1] << ',' << knotsurface[i].normal[2] << ") \n";        A += knotsurface[i].area;        i++;    }        NK = i;        return A;    }/*************************Functions for B and Phi calcs*****************************/void initial_cond(double *x, double *y, double *z, double *phi, int *missed){    int *ignore;  //Points to ignore    int *ignore1;    double *Bx;  //Mag field    double *By;    double *Bz;    double *Bmag;    int i,j,k;        ignore = new int [Nx*Ny*Nz];    ignore1 = new int [Nx*Ny*Nz];    Bx = new double [Nx*Ny*Nz];    By = new double [Nx*Ny*Nz];    Bz = new double [Nx*Ny*Nz];    Bmag = new double [Nx*Ny*Nz];        double timesec = 30.0*Nx*Ny*Nz*NK/(101*101*81*1322);    unsigned int tt = ((int) timesec);    cout << "Calculating scalar potential ~ " << tt/60 << "m " << tt%60 << "s...\n";    phi_calc(x,y,z,missed, phi);    cout << "Printing B and phi...\n";    print_B_phi(x, y, z, missed, phi);        delete [] ignore;    delete [] ignore1;    delete [] Bx;    delete [] By;    delete [] Bz;    delete [] Bmag;}void phi_calc(double *x, double *y, double *z, int *missed, double *phi){    int i,j,k,n,s;    double rx,ry,rz,r;        for(i=0;i<Nx;i++)    {        for(j=0;j<Ny;j++)        {            for(k=0;k<Nz;k++)            {                n = pt(i,j,k);                missed[n] = 0;                phi[n] = 0;                for(s=0;s<NK;s++)                {                    rx = knotsurface[s].centre[0]-x[i];                    ry = knotsurface[s].centre[1]-y[j];                    rz = knotsurface[s].centre[2]-z[k];                    r = sqrt(rx*rx+ry*ry+rz*rz);                    if(r<coresize) missed[n] = 1;                    if(r>0) phi[n] += (rx*knotsurface[s].normal[0] + ry*knotsurface[s].normal[1] + rz*knotsurface[s].normal[2])*knotsurface[s].area/(2*r*r*r);                }                if(missed[n]) phi[n] = M_PI;                if(phi[n]>M_PI) phi[n] = M_PI;                if(phi[n]<-M_PI) phi[n] = -M_PI;            }        }    }    }/*************************Functions for FN dynamics*****************************/void uv_initialise(double *phi, double *u, double *v, double *ucv, int *missed){    int n;        for(n=0; n<Nx*Ny*Nz; n++)    {        u[n] = (2*cos(phi[n]) - 0.4);        v[n] = (sin(phi[n]) - 0.4);        //if missed set value to -0.4 (vortex centre value)    }}void crossgrad_calc(double *u, double *v, double *ucv){    int i,j,k;    double dxu,dyu,dzu,dxv,dyv,dzv,ucvx,ucvy,ucvz;        for(i=0;i<Nx;i++)    {        for(j=0; j<Ny; j++)        {            for(k=0; k<Nz; k++)   //Central difference            {                dxu = 0.5*(u[pt(incw(i,1,Nx),j,k)]-u[pt(incw(i,-1,Nx),j,k)])/h;                dxv = 0.5*(v[pt(incw(i,1,Nx),j,k)]-v[pt(incw(i,-1,Nx),j,k)])/h;                dyu = 0.5*(u[pt(i,incw(j,1,Ny),k)]-u[pt(i,incw(j,-1,Ny),k)])/h;                dyv = 0.5*(v[pt(i,incw(j,1,Ny),k)]-v[pt(i,incw(j,-1,Ny),k)])/h;                dzu = 0.5*(u[pt(i,j,incw(k,1,Nz))]-u[pt(i,j,incw(k,-1,Nz))])/h;                dzv = 0.5*(v[pt(i,j,incw(k,1,Nz))]-v[pt(i,j,incw(k,-1,Nz))])/h;                ucvx = dyu*dzv - dzu*dyv;                ucvy = dzu*dxv - dxu*dzv;                ucvz = dxu*dyv - dyu*dxv;                ucv[pt(i,j,k)] = sqrt(ucvx*ucvx + ucvy*ucvy + ucvz*ucvz);            }        }    }}void uv_update(double *u, double *v){    int i,j,k,l,n;    double D2u, **ku, **kv, *uold, *vold;        ku = new double* [4];    kv = new double* [4];    uold = new double [Nx*Ny*Nz];    vold = new double [Nx*Ny*Nz];        for(l=0;l<4;l++)    {        ku[l] = new double [Nx*Ny*Nz];        kv[l] = new double [Nx*Ny*Nz];    }        for(i=0;i<Nx;i++)    {        for(j=0; j<Ny; j++)        {            for(k=0; k<Nz; k++)            {                n = pt(i,j,k);                uold[n] = u[n];  //old value of u                vold[n] = v[n];  //old value of v            }        }    }        for(l=0;l<4;l++)  //u and v update for each fractional time step    {        for(i=0;i<Nx;i++)        {            for(j=0; j<Ny; j++)            {                for(k=0; k<Nz; k++)   //Central difference                {                    n = pt(i,j,k);                    D2u = (u[pt(incw(i,1,Nx),j,k)] + u[pt(incw(i,-1,Nx),j,k)] + u[pt(i,incw(j,1,Ny),k)] + u[pt(i,incw(j,-1,Ny),k)] + u[pt(i,j,incw(k,1,Nz))] + u[pt(i,j,incw(k,-1,Nz))] - 6*u[n])/(h*h);                    ku[l][n] = (u[n] - u[n]*u[n]*u[n]/3 - v[n])/epsilon + D2u;                    kv[l][n] = epsilon*(u[n] + beta - gam*v[n]);                }            }        }                for(i=0;i<Nx;i++)        {            for(j=0; j<Ny; j++)            {                for(k=0; k<Nz; k++)  //update                {                    n = pt(i,j,k);                    if(l==0 || l==1)                    {                        u[n] = uold[n] + 0.5*dtime*ku[l][n];                        v[n] = vold[n] + 0.5*dtime*kv[l][n];                    }                    else                    {                        if(l==2)                        {                            u[n] = uold[n] + dtime*ku[l][n];                            v[n] = vold[n] + dtime*kv[l][n];                        }                        else                        {                            u[n] = uold[n] + dtime*(ku[0][n] + 2*ku[1][n] + 2*ku[2][n] + ku[3][n])/6;                            v[n] = vold[n] + dtime*(kv[0][n] + 2*kv[1][n] + 2*kv[2][n] + kv[3][n])/6;                        }                    }                }            }        }    }        for(l=0;l<4;l++)    {        delete [] ku[l];        delete [] kv[l];    }        delete [] uold;    delete [] vold;    delete [] ku;    delete [] kv;}/*************************File reading and writing*****************************/void print_uv(double *u, double *v, double *ucv, double t){    int i,j,k,n;    stringstream ss;    ss << "uv_plot" << t << ".vtk";    ofstream uvout (ss.str().c_str());        uvout << "# vtk DataFile Version 3.0\nUV fields\nASCII\nDATASET STRUCTURED_POINTS\n";    uvout << "DIMENSIONS " << Nx << ' ' << Ny << ' ' << Nz << '\n';    uvout << "ORIGIN " << -0.5*Nx*h << ' ' << -0.5*Ny*h << ' ' << -0.5*Nz*h << '\n';    uvout << "SPACING " << h << ' ' << h << ' ' << h << '\n';    uvout << "POINT_DATA " << Nx*Ny*Nz << '\n';    uvout << "SCALARS u float\nLOOKUP_TABLE default\n";            for(k=0; k<Nz; k++)    {        for(j=0; j<Ny; j++)        {            for(i=0; i<Nx; i++)            {                n = pt(i,j,k);                uvout << u[n] << '\n';            }        }    }        uvout << "SCALARS v float\nLOOKUP_TABLE default\n";            for(k=0; k<Nz; k++)    {        for(j=0; j<Ny; j++)        {            for(i=0; i<Nx; i++)            {                n = pt(i,j,k);                uvout << v[n] << '\n';            }        }    }        uvout << "SCALARS ucrossv float\nLOOKUP_TABLE default\n";        for(k=0; k<Nz; k++)    {        for(j=0; j<Ny; j++)        {            for(i=0; i<Nx; i++)            {                n = pt(i,j,k);                uvout << ucv[n] << '\n';            }        }    }        uvout.close();}void print_B_phi(double *x, double *y, double*z, int *missed, double *phi){    int i,j,k,n;    string fn = "phi.vtk";        ofstream Bout (fn.c_str());        Bout << "# vtk DataFile Version 3.0\nKnot\nASCII\nDATASET STRUCTURED_POINTS\n";    Bout << "DIMENSIONS " << Nx << ' ' << Ny << ' ' << Nz << '\n';    Bout << "ORIGIN " << -0.5*Nx*h << ' ' << -0.5*Ny*h << ' ' << -0.5*Nz*h << '\n';    Bout << "SPACING " << h << ' ' << h << ' ' << h << '\n';    Bout << "POINT_DATA " << Nx*Ny*Nz << '\n';    Bout << "SCALARS Phi float\nLOOKUP_TABLE default\n";    for(k=0; k<Nz; k++)    {        for(j=0; j<Ny; j++)        {            for(i=0; i<Nx; i++)            {                n = pt(i,j,k);                Bout << phi[n] << '\n';            }        }    }        Bout << "SCALARS Missed float\nLOOKUP_TABLE default\n";    for(k=0; k<Nz; k++)    {        for(j=0; j<Ny; j++)        {            for(i=0; i<Nx; i++)            {                n = pt(i,j,k);                Bout << missed[n] << '\n';            }        }    }        Bout.close();}int phi_file_read(double *phi, int *missed){    string temp,buff;    stringstream ss;    ifstream fin (B_filename.c_str());    int i,j,k,n;        for(i=0;i<10;i++)    {        if(fin.good())        {            if(getline(fin,buff)) temp = buff;        }        else        {            cout << "Something went wrong!\n";            return 1;        }    }        for(k=0; k<Nz; k++)    {        for(j=0; j<Ny; j++)        {            for(i=0; i<Nx; i++)            {                n=pt(i,j,k);                ss.clear();                ss.str("");                if(fin.good())                {                    if(getline(fin,buff))                    {                        ss << buff;                        ss >> phi[n];                    }                }                else                {                    cout << "Something went wrong!\n";                    return 1;                }            }        }    }        for(i=0;i<2;i++)    {        if(fin.good())        {            if(getline(fin,buff)) temp = buff;        }        else        {            cout << "Something went wrong!\n";            return 1;        }    }        for(k=0; k<Nz; k++)    {        for(j=0; j<Ny; j++)        {            for(i=0; i<Nx; i++)            {                n=pt(i,j,k);                ss.clear();                ss.str("");                if(fin.good())                {                    if(getline(fin,buff)) ss << buff;                    ss >> missed[n];                }                else                {                    cout << "Something went wrong!\n";                    return 1;                }            }        }    }        fin.close();        return 0;}int uvfile_read(double *u, double *v){    string temp,buff;    stringstream ss;    ifstream fin (B_filename.c_str());    int i,j,k,n;        for(i=0;i<10;i++)    {        if(fin.good())        {            if(getline(fin,buff)) temp = buff;        }        else        {            cout << "Something went wrong!\n";            return 1;        }    }        for(k=0; k<Nz; k++)    {        for(j=0; j<Ny; j++)        {            for(i=0; i<Nx; i++)            {                n=pt(i,j,k);                ss.clear();                ss.str("");                if(fin.good())                {                    if(getline(fin,buff))                    {                        ss << buff;                        ss >> u[n];                    }                }                else                {                    cout << "Something went wrong!\n";                    return 1;                }            }        }    }        for(i=0;i<2;i++)    {        if(fin.good())        {            if(getline(fin,buff)) temp = buff;        }        else        {            cout << "Something went wrong!\n";            return 1;        }    }        for(k=0; k<Nz; k++)    {        for(j=0; j<Ny; j++)        {            for(i=0; i<Nx; i++)            {                n=pt(i,j,k);                ss.clear();                ss.str("");                if(fin.good())                {                    if(getline(fin,buff)) ss << buff;                    ss >> v[n];                }                else                {                    cout << "Something went wrong!\n";                    return 1;                }            }        }    }        fin.close();        return 0;}